import { useEffect, useRef, useState } from 'react'
import { Navigation, Maximize2, Eye, EyeOff, Expand, Shrink, AlertTriangle } from 'lucide-react'
import * as Cesium from 'cesium'
import { Drone } from '@/lib/types'
import { toast } from '@/components/ui/toaster'
Cesium.Ion.defaultAccessToken = import.meta.env.VITE_CESIUM_ION_TOKEN

/**
 * Route represents a delivery flight path from pickup to delivery location.
 * These are NOT pre-defined operational routes between Bengaluru locations.
 * 
 * Routes are:
 * - Generated by the backend route optimizer (apps/routes/ai/route_optimizer.py)
 * - Created per delivery order when a drone is assigned
 * - Optimized paths that avoid no-fly zones and weather hazards
 * - Stored in the database (backend/apps/routes/models.py - Route model)
 * - Fetched from /api/routes/ endpoint for active orders
 * 
 * Each route contains:
 * - id: Database route ID
 * - path: Array of 3D waypoints (lat, lng, altitude) the drone follows
 * - color: Visual color for rendering (green=completed, cyan=in-progress)
 * - completed: Whether delivery is finished
 */
interface Route {
  id: number
  path: Array<{ lat: number; lng: number; altitude: number }>
  color?: string
  completed?: boolean
}

interface Zone {
  id: number
  name: string
  type: 'operational' | 'no-fly'
  polygon: Array<{ lat: number; lng: number }>
  center?: { lat: number; lng: number }
  radiusMeters?: number
  altitudeRange?: { min: number; max: number }
}

interface CollisionEvent {
  droneId: number
  droneSerial: string
  type: 'drone' | 'building' | 'terrain'
  targetId?: number
  targetSerial?: string
  position: { lat: number; lng: number; altitude: number }
  timestamp: Date
}

interface Map3DProps {
  drones?: Drone[]
  routes?: Route[]
  zones?: Zone[]
  onDroneClick?: (droneId: number) => void
  onZoneClick?: (zoneId: number) => void
  followDrone?: number | null
  showLabels?: boolean
  showZones?: boolean
  homePosition?: { lat: number; lng: number; altitude: number }
  enableFullscreen?: boolean
  onCollisionDetected?: (collision: CollisionEvent) => void
}

export default function Map3D({
  drones = [],
  routes = [],
  zones = [],
  onDroneClick,
  onZoneClick,
  followDrone = null,
  showLabels = true,
  showZones = true,
  homePosition = { lat: 12.9716, lng: 77.5946, altitude: 50000 }, // Bangalore
  enableFullscreen = true,
  onCollisionDetected
}: Map3DProps): JSX.Element {
  const cesiumContainer = useRef<HTMLDivElement>(null)
  const viewerRef = useRef<Cesium.Viewer | null>(null)
  const entitiesRef = useRef<Map<string, Cesium.Entity>>(new Map())
  const buildingTilesetRef = useRef<Cesium.Cesium3DTileset | null>(null)
  const initializedRef = useRef(false) // React 18 Strict Mode protection
  
  const [cameraMode, setCameraMode] = useState<'free' | 'follow'>('free')
  const [showBuildings, setShowBuildings] = useState(true)
  const [isFullscreen, setIsFullscreen] = useState(false)
  const [collisions, setCollisions] = useState<CollisionEvent[]>([])
  const [crashedDrones, setCrashedDrones] = useState<Set<number>>(new Set())
  
  // Collision detection constants
  const SAFE_SPACING_METERS = 50 // Minimum safe distance between drones
  const COLLISION_THRESHOLD_METERS = 10 // Critical collision distance
  const TERRAIN_COLLISION_THRESHOLD = 2 // Minimum altitude above terrain

  // Collision detection helper
  const calculateDistance = (pos1: Cesium.Cartesian3, pos2: Cesium.Cartesian3): number => {
    return Cesium.Cartesian3.distance(pos1, pos2)
  }

  const logCollision = (collision: CollisionEvent) => {
    console.error('üî¥ COLLISION DETECTED:', collision)
    console.error('üö® CODE RED - DRONE CRASH')
    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
    console.error(`Drone: ${collision.droneSerial} (ID: ${collision.droneId})`)
    console.error(`Type: ${collision.type.toUpperCase()}`)
    if (collision.targetSerial) {
      console.error(`Collided with: ${collision.targetSerial} (ID: ${collision.targetId})`)
    }
    console.error(`Location: ${collision.position.lat.toFixed(6)}, ${collision.position.lng.toFixed(6)}, ${collision.position.altitude.toFixed(1)}m`)
    console.error(`Timestamp: ${collision.timestamp.toISOString()}`)
    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
    
    // Add to collision history
    setCollisions(prev => [...prev, collision])
    
    // Mark drone as crashed
    setCrashedDrones(prev => new Set(prev).add(collision.droneId))
    
    // Show critical toast alert
    toast.error(
      `üö® DRONE CRASH: ${collision.droneSerial} collided with ${collision.type === 'drone' ? collision.targetSerial : collision.type}`,
      'Critical Collision Detected'
    )
    
    // Notify parent component
    onCollisionDetected?.(collision)
  }

  const checkCollisions = () => {
    if (!viewerRef.current || viewerRef.current.isDestroyed() || drones.length === 0) return

    drones.forEach((drone, index) => {
      if (!drone.position || !drone.id || crashedDrones.has(drone.id)) return

      const baseAlt = drone.status && ['idle', 'maintenance', 'charging'].includes(drone.status) ? 0 : (drone.position.altitude || 80)
      const safeAltitude = Math.max(20, baseAlt)
      const dronePosition = Cesium.Cartesian3.fromDegrees(
        drone.position.lng,
        drone.position.lat,
        safeAltitude
      )

      // Check drone-to-drone collisions
      for (let i = index + 1; i < drones.length; i++) {
        const otherDrone = drones[i]
        if (!otherDrone.position || !otherDrone.id || crashedDrones.has(otherDrone.id)) continue

        const otherAlt = otherDrone.status && ['idle', 'maintenance', 'charging'].includes(otherDrone.status) ? 0 : (otherDrone.position.altitude || 80)
        const otherSafeAltitude = Math.max(20, otherAlt)
        const otherPosition = Cesium.Cartesian3.fromDegrees(
          otherDrone.position.lng,
          otherDrone.position.lat,
          otherSafeAltitude
        )

        const distance = calculateDistance(dronePosition, otherPosition)

        if (distance < COLLISION_THRESHOLD_METERS) {
          // CRITICAL COLLISION
          logCollision({
            droneId: drone.id,
            droneSerial: drone.serial_number,
            type: 'drone',
            targetId: otherDrone.id,
            targetSerial: otherDrone.serial_number,
            position: drone.position,
            timestamp: new Date()
          })
        }
      }

      // Check building collisions (simplified check using altitude)
      if (showBuildings && safeAltitude < 50) {
        // Assume buildings in urban areas can be up to 50m
        // More sophisticated check would use actual building tileset
        const buildingRisk = Math.random() < 0.01 // Small chance to detect building collision
        if (buildingRisk) {
          logCollision({
            droneId: drone.id,
            droneSerial: drone.serial_number,
            type: 'building',
            position: drone.position,
            timestamp: new Date()
          })
        }
      }

      // Check terrain collision
      if (safeAltitude < TERRAIN_COLLISION_THRESHOLD) {
        logCollision({
          droneId: drone.id,
          droneSerial: drone.serial_number,
          type: 'terrain',
          position: drone.position,
          timestamp: new Date()
        })
      }
    })
  }

  // Apply spacing when drones spawn
  const applyDroneSpacing = (drone: Drone, existingDrones: Drone[]): { lat: number; lng: number } => {
    if (!drone.position) return { lat: 12.9716, lng: 77.5946 }

    let adjustedLat = drone.position.lat
    let adjustedLng = drone.position.lng
    let attempts = 0
    const maxAttempts = 50

    while (attempts < maxAttempts) {
      let tooClose = false

      for (const other of existingDrones) {
        if (!other.position || other.id === drone.id) continue

        const pos1 = Cesium.Cartesian3.fromDegrees(adjustedLng, adjustedLat, drone.position.altitude || 80)
        const pos2 = Cesium.Cartesian3.fromDegrees(other.position.lng, other.position.lat, other.position.altitude || 80)
        const distance = calculateDistance(pos1, pos2)

        if (distance < SAFE_SPACING_METERS) {
          tooClose = true
          // Offset position slightly
          const offsetAngle = Math.random() * 2 * Math.PI
          const offsetDistance = SAFE_SPACING_METERS / 111000 // Convert meters to degrees (approx)
          adjustedLat += Math.cos(offsetAngle) * offsetDistance
          adjustedLng += Math.sin(offsetAngle) * offsetDistance
          break
        }
      }

      if (!tooClose) break
      attempts++
    }

    if (attempts >= maxAttempts) {
      console.warn(`‚ö†Ô∏è Could not find safe spacing for drone ${drone.serial_number} after ${maxAttempts} attempts`)
    }

    return { lat: adjustedLat, lng: adjustedLng }
  }

  // Collision detection interval
  useEffect(() => {
    const interval = setInterval(checkCollisions, 1000) // Check every second
    return () => clearInterval(interval)
  }, [drones, showBuildings, crashedDrones])

  // Initialize Cesium Viewer
  useEffect(() => {
    // React 18 Strict Mode protection - prevent double initialization
    if (initializedRef.current) return
    
    console.log('üîÑ Map3D useEffect triggered - checking initialization conditions')
    console.log('cesiumContainer.current:', !!cesiumContainer.current)
    console.log('viewerRef.current:', !!viewerRef.current)
    console.log('Cesium Container Client Width and Height:',cesiumContainer.current?.clientWidth,cesiumContainer.current?.clientHeight);


    if (!cesiumContainer.current || viewerRef.current) {
      console.log('‚è≠Ô∏è Skipping viewer initialization')
      return
    }

    // FIX 2: Delay viewer init until container is measurable
    const { clientWidth, clientHeight } = cesiumContainer.current
    if (clientWidth === 0 || clientHeight === 0) {
      console.warn('‚ö†Ô∏è Container has zero dimensions, deferring Cesium init')
      return
    }

    console.log('‚úÖ Starting viewer initialization with container size:', clientWidth, 'x', clientHeight)

    let viewer: Cesium.Viewer | null = null
    let cancelled = false // Cancellation flag for async operations

    const initViewer = async () => {
      console.log('üó∫Ô∏è Initializing CesiumJS Viewer...')

      try {
        viewer = new Cesium.Viewer(cesiumContainer.current!, {
          // Terrain
          terrainProvider: await Cesium.createWorldTerrainAsync({
            requestWaterMask: true,
            requestVertexNormals: true
          }),

          // UI
          animation: false,
          timeline: false,
          fullscreenButton: false,
          vrButton: false,
          homeButton: false,
          sceneModePicker: false,
          navigationHelpButton: false,
          geocoder: false,

          // Performance (FIX 4: Disable continuous rendering)
          requestRenderMode: true,
          maximumRenderTimeChange: Infinity,
          shadows: false,
        })

        // Check if component unmounted during async terrain creation
        if (cancelled) {
          console.warn('‚ö†Ô∏è Component unmounted during terrain init, destroying viewer')
          viewer.destroy()
          return
        }

        // Store viewer reference immediately after creation
        viewerRef.current = viewer
        initializedRef.current = true

        console.log('üì° Setting up imagery provider (Cesium Ion world imagery)')
        viewer.imageryLayers.removeAll()
        const ionImagery = await Cesium.IonImageryProvider.fromAssetId(2)
        
        if (cancelled) {
          console.warn('‚ö†Ô∏è Component unmounted during imagery init')
          return
        }
        
        viewer.imageryLayers.addImageryProvider(ionImagery)

        console.log('üè¢ Adding OSM Buildings')
        // Add OSM Buildings
        const buildingTileset = await Cesium.createOsmBuildingsAsync()
        
        if (cancelled) {
          console.warn('‚ö†Ô∏è Component unmounted during buildings init')
          return
        }
        
        buildingTileset.show = showBuildings
        buildingTilesetRef.current = buildingTileset
        viewer.scene.primitives.add(buildingTileset)

        console.log('üì∑ Setting initial camera position')
        // Set initial camera position
        viewer.camera.setView({
          destination: Cesium.Cartesian3.fromDegrees(
            homePosition.lng,
            homePosition.lat,
            homePosition.altitude
          ),
          orientation: {
            heading: Cesium.Math.toRadians(0),
            pitch: Cesium.Math.toRadians(-45),
            roll: 0
          }
        })

        // Enable lighting but keep effects light for performance
        viewer.scene.globe.enableLighting = true
        viewer.scene.postProcessStages.fxaa.enabled = false
        viewer.scene.globe.tileCacheSize = 50
        viewer.scene.globe.maximumScreenSpaceError = 4
        viewer.scene.highDynamicRange = false

        console.log('üñ±Ô∏è Setting up click handler')
        // Click handler
        viewer.screenSpaceEventHandler.setInputAction((movement: any) => {
          if (!viewer) return
          const pickedObject = viewer.scene.pick(movement.position)

          if (Cesium.defined(pickedObject) && pickedObject.id) {
            const entity = pickedObject.id

            if (entity.id.startsWith('drone-')) {
              const droneId = parseInt(entity.id.split('-')[1])
              onDroneClick?.(droneId)
            } else if (entity.id.startsWith('zone-')) {
              const zoneId = parseInt(entity.id.split('-')[1])
              onZoneClick?.(zoneId)
            }
          }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK)

        // Request initial render
        viewer.scene.requestRender()

        console.log('‚úÖ Cesium Viewer initialized successfully')
        console.log('üìä Initial stats', {
          drones: drones.length,
          routes: routes.length,
          zones: zones.length
        })
      } catch (error) {
        console.error('‚ùå Error initializing Cesium Viewer:', error)
      }
    }

    initViewer()

    // FIX 1 & 3: CRITICAL - Hard stop render loop before destroy + cancellation
    return () => {
      console.log('üßπ Cleanup function called')
      cancelled = true // Cancel any pending async operations

      const viewer = viewerRef.current
      if (viewer && !viewer.isDestroyed()) {
        console.log('üßπ Freezing Cesium render loop')

        // üî¥ HARD STOP rendering - prevent any frame from rendering during teardown
        viewer.clock.shouldAnimate = false
        viewer.scene.requestRenderMode = true
        viewer.scene.maximumRenderTimeChange = Infinity

        // Remove event handlers safely to prevent callbacks on destroyed viewer
        try {
          viewer.screenSpaceEventHandler?.removeInputAction(
            Cesium.ScreenSpaceEventType.LEFT_CLICK
          )
        } catch (e) {
          console.warn('‚ö†Ô∏è Error removing input action:', e)
        }

        // Remove primitives explicitly (important for OSM Buildings)
        viewer.scene.primitives.removeAll()
        viewer.entities.removeAll()

        // DO NOT call requestRender() here - rendering while destroying causes WebGL errors
        console.log('üßπ Destroying Cesium Viewer')
        viewer.destroy()
      }

      viewerRef.current = null
      buildingTilesetRef.current = null
    }
  }, []) // Remove dependencies to prevent re-initialization

  // FIX 5: Handle resize correctly with zero-size protection
  useEffect(() => {
    const handleResize = () => {
      const container = cesiumContainer.current
      const viewer = viewerRef.current
      
      // Zero-size protection
      if (!container || !viewer || viewer.isDestroyed()) return
      if (container.clientWidth === 0 || container.clientHeight === 0) {
        console.warn('‚ö†Ô∏è Skipping resize - container has zero dimensions')
        return
      }

      viewer.resize()
      viewer.scene.requestRender()
      console.log('üîÑ Viewer resized to:', container.clientWidth, 'x', container.clientHeight)
    }

    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  // Update drone entities
  useEffect(() => {
    // FIX 5: Canvas size guard - prevent drawing into zero-sized canvas
    const viewer = viewerRef.current
    if (!viewer || viewer.isDestroyed()) return
    if (viewer.canvas.clientWidth === 0 || viewer.canvas.clientHeight === 0) {
      console.warn('‚ö†Ô∏è Skipping drone update - canvas has zero dimensions')
      return
    }

    console.debug('üõ∞Ô∏è Updating drones', { count: drones.length })

    // Remove old drones
    entitiesRef.current.forEach((entity, key) => {
      if (key.startsWith('drone-')) {
        const droneId = parseInt(key.split('-')[1])
        if (!drones.find(d => d.id === droneId)) {
          viewer.entities.remove(entity)
          entitiesRef.current.delete(key)
        }
      }
    })

    // Add/update drones with spacing
    const processedDrones: Drone[] = []
    drones.forEach(drone => {
      const entityId = `drone-${drone.id}`
      let entity = entitiesRef.current.get(entityId)

      if (!drone.position) return; // Skip if no position data

      // Apply spacing for new drones
      const adjustedPosition = entity ? { lat: drone.position.lat, lng: drone.position.lng } : applyDroneSpacing(drone, processedDrones)
      processedDrones.push(drone)

      const baseAlt = drone.status && ['idle', 'maintenance', 'charging'].includes(drone.status) ? 0 : (drone.position.altitude || 80)
      const safeAltitude = Math.max(20, baseAlt)

      const position = Cesium.Cartesian3.fromDegrees(
        adjustedPosition.lng,
        adjustedPosition.lat,
        safeAltitude
      )

      // Check if drone crashed
      const isCrashed = drone.id ? crashedDrones.has(drone.id) : false

      if (entity) {
        // Update existing entity
        entity.position = new Cesium.ConstantPositionProperty(position)

        if (drone.heading !== undefined) {
          entity.orientation = new Cesium.ConstantProperty(
            Cesium.Transforms.headingPitchRollQuaternion(
              position,
              new Cesium.HeadingPitchRoll(
                Cesium.Math.toRadians(drone.heading),
                Cesium.Math.toRadians(drone.pitch || 0),
                Cesium.Math.toRadians(drone.roll || 0)
              )
            )
          )
        }
      } else {
        // Create new entity
        entity = viewer.entities.add({
          id: entityId,
          name: drone.serial_number,
          position: position,

          // 3D Model (use actual drone GLTF model)
          model: {
            uri: '/models/drone1.glb',
            minimumPixelSize: 64,
            maximumScale: 20000,
            scale: 1.0
          },

          point: {
            pixelSize: isCrashed ? 15 : 10,
            color: isCrashed ? Cesium.Color.RED : getStatusColor(drone.status),
            outlineColor: isCrashed ? Cesium.Color.YELLOW : Cesium.Color.WHITE,
            outlineWidth: isCrashed ? 3 : 2,
            heightReference: Cesium.HeightReference.NONE
          },

          label: showLabels ? {
            text: isCrashed ? `üö® CRASHED\n${drone.serial_number}` : `${drone.serial_number}\n${drone.battery || drone.battery_level}%`,
            font: isCrashed ? 'bold 14px sans-serif' : '12px sans-serif',
            fillColor: isCrashed ? Cesium.Color.RED : Cesium.Color.WHITE,
            outlineColor: isCrashed ? Cesium.Color.YELLOW : Cesium.Color.BLACK,
            outlineWidth: isCrashed ? 3 : 2,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
            pixelOffset: new Cesium.Cartesian2(0, isCrashed ? -30 : -20),
            heightReference: Cesium.HeightReference.NONE
          } : undefined,

          // Description for info box
          description: `
            <div>
              <p><strong>Serial:</strong> ${drone.serial_number}</p>
              <p><strong>Status:</strong> ${drone.status}</p>
              <p><strong>Battery:</strong> ${drone.battery || drone.battery_level}%</p>
              <p><strong>Position:</strong> ${drone.position!.lat.toFixed(6)}, ${drone.position!.lng.toFixed(6)}</p>
              <p><strong>Altitude:</strong> ${drone.position!.altitude.toFixed(1)}m</p>
            </div>
          `
        })

        entitiesRef.current.set(entityId, entity)
      }
    })

    // Request render after updating drones
    viewer.scene.requestRender()
  }, [drones, showLabels, crashedDrones])

  // Update routes
  useEffect(() => {
    // FIX 5: Canvas size guard
    const viewer = viewerRef.current
    if (!viewer || viewer.isDestroyed()) return
    if (viewer.canvas.clientWidth === 0 || viewer.canvas.clientHeight === 0) {
      console.warn('‚ö†Ô∏è Skipping routes update - canvas has zero dimensions')
      return
    }

    console.debug('üõ£Ô∏è Updating routes', { count: routes.length })

    // Remove old routes
    entitiesRef.current.forEach((entity, key) => {
      if (key.startsWith('route-')) {
        const routeId = parseInt(key.split('-')[1])
        if (!routes.find(r => r.id === routeId)) {
          viewer.entities.remove(entity)
          entitiesRef.current.delete(key)
        }
      }
    })

    // Add routes
    routes.forEach(route => {
      const entityId = `route-${route.id}`

      if (!entitiesRef.current.has(entityId)) {
        const positions = route.path.map(p =>
          Cesium.Cartesian3.fromDegrees(p.lng, p.lat, p.altitude)
        )

        if (!positions.length) {
          console.warn('‚ö†Ô∏è Route has no positions', route.id)
          return
        }

        const entity = viewer.entities.add({
          id: entityId,
          polyline: {
            positions: positions,
            width: route.completed ? 4 : 2,
            material: route.completed
              ? Cesium.Color.fromCssColorString(route.color || '#00FF00')
              : new Cesium.PolylineDashMaterialProperty({
                  color: Cesium.Color.fromCssColorString(route.color || '#00FFFF'),
                  dashLength: 16.0
                }),
            clampToGround: false,
            arcType: Cesium.ArcType.NONE
          },

          // Waypoint markers
          ...route.path.map((waypoint, index) => ({
            position: Cesium.Cartesian3.fromDegrees(waypoint.lng, waypoint.lat, waypoint.altitude),
            point: {
              pixelSize: 6,
              color: Cesium.Color.YELLOW,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 1
            },
            label: {
              text: `WP${index + 1}`,
              font: '10px sans-serif',
              fillColor: Cesium.Color.YELLOW,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 1,
              pixelOffset: new Cesium.Cartesian2(0, -10),
              show: showLabels
            }
          }))
        })

        entitiesRef.current.set(entityId, entity)
      }
    })
    // Request render after updating routes
    viewer.scene.requestRender()  }, [routes, showLabels])

  // Update zones
  useEffect(() => {
    // FIX 5: Canvas size guard
    const viewer = viewerRef.current
    if (!viewer || viewer.isDestroyed() || !showZones) return
    if (viewer.canvas.clientWidth === 0 || viewer.canvas.clientHeight === 0) {
      console.warn('‚ö†Ô∏è Skipping zones update - canvas has zero dimensions')
      return
    }

    console.debug('üõë Updating zones', { count: zones.length })

    // Remove old zones
    entitiesRef.current.forEach((entity, key) => {
      if (key.startsWith('zone-')) {
        const zoneId = parseInt(key.split('-')[1])
        if (!zones.find(z => z.id === zoneId)) {
          viewer.entities.remove(entity)
          entitiesRef.current.delete(key)
        }
      }
    })

    // Add zones
    zones.forEach(zone => {
      const entityId = `zone-${zone.id}`

      if (!entitiesRef.current.has(entityId)) {
        const positions = zone.polygon.map(p =>
          Cesium.Cartesian3.fromDegrees(p.lng, p.lat, 0)
        )

        const maxAlt = Math.max(50, (zone.altitudeRange?.max || 400) / 2)
        const minAlt = Math.max(0, (zone.altitudeRange?.min || 0))
        if (!positions.length && !(zone.center && zone.radiusMeters)) {
          console.warn('‚ö†Ô∏è Zone has no geometry', zone)
          return
        }

        const baseColor = zone.type === 'no-fly'
          ? Cesium.Color.RED
          : Cesium.Color.fromCssColorString('#facc15') // yellow
        const fillColor = baseColor.withAlpha(0.18)
        const outlineColor = baseColor.withAlpha(0.9)

        const entity = viewer.entities.add({
          id: entityId,
          name: zone.name,
          polygon: positions.length ? {
            hierarchy: new Cesium.PolygonHierarchy(positions),
            material: fillColor,
            outline: true,
            outlineColor: outlineColor,
            outlineWidth: 2,
            height: minAlt,
            extrudedHeight: maxAlt,
            perPositionHeight: false
          } : undefined,
          ellipse: zone.center && zone.radiusMeters ? {
            semiMajorAxis: zone.radiusMeters,
            semiMinorAxis: zone.radiusMeters,
            height: minAlt,
            extrudedHeight: Math.max(30, maxAlt / 2),
            material: fillColor,
            outline: true,
            outlineColor: outlineColor,
            outlineWidth: 3,
            stRotation: 0
          } : undefined,
          position: zone.center
            ? Cesium.Cartesian3.fromDegrees(zone.center.lng, zone.center.lat, zone.altitudeRange?.min || 0)
            : undefined,
          label: {
            text: zone.name,
            font: '14px sans-serif',
            fillColor: Cesium.Color.WHITE,
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            pixelOffset: new Cesium.Cartesian2(0, 0),
            show: showLabels
          }
        })

        entitiesRef.current.set(entityId, entity)
      }
    })

    // Request render after updating zones
    viewer.scene.requestRender()
  }, [zones, showZones, showLabels])

  // Camera follow mode
  useEffect(() => {
    // FIX 5: Canvas size guard
    const viewer = viewerRef.current
    if (!viewer || viewer.isDestroyed() || !followDrone) return
    if (viewer.canvas.clientWidth === 0 || viewer.canvas.clientHeight === 0) {
      console.warn('‚ö†Ô∏è Skipping camera follow - canvas has zero dimensions')
      return
    }

    const entity = entitiesRef.current.get(`drone-${followDrone}`)

    if (entity) {
      viewer.trackedEntity = entity
      setCameraMode('follow')
      viewer.scene.requestRender()
    }
  }, [followDrone])

  // Handle drone click
  // const handleDroneClick = (droneId: number) => {
  //   setSelectedDrone(droneId)
  //   if (onDroneClick) {
  //     onDroneClick(droneId)
  //   }
  // }

  // Camera controls
  const handleFitToView = () => {
    if (!viewerRef.current || viewerRef.current.isDestroyed()) return
    console.log('üì∑ Fitting all entities to view')
    // In production: viewerRef.current.zoomTo(viewerRef.current.entities)
  }

  const handleResetCamera = () => {
    if (!viewerRef.current || viewerRef.current.isDestroyed()) return
    console.log('üì∑ Resetting camera to home position')
    setCameraMode('free')
    // In production: viewerRef.current.camera.flyHome()
  }

  const toggleBuildings = () => {
    if (!viewerRef.current || viewerRef.current.isDestroyed()) return

    const next = !showBuildings
    setShowBuildings(next)
    console.log(`üè¢ Buildings: ${next ? 'shown' : 'hidden'}`)

    if (buildingTilesetRef.current) {
      buildingTilesetRef.current.show = next
      if (viewerRef.current && !viewerRef.current.isDestroyed()) {
        viewerRef.current.scene.requestRender()
      }
    }
  }

  const handleFullscreenToggle = () => {
    const next = !isFullscreen
    setIsFullscreen(next)
    document.body.style.overflow = next ? 'hidden' : ''
  }

  const getStatusColor = (status?: string) => {
    switch (status) {
      case 'active': return Cesium.Color.GREEN
      case 'idle': return Cesium.Color.YELLOW
      case 'maintenance': return Cesium.Color.ORANGE
      case 'emergency': return Cesium.Color.RED
      case 'delivering': return Cesium.Color.CYAN
      case 'returning': return Cesium.Color.fromCssColorString('#22c55e')
      case 'charging': return Cesium.Color.fromCssColorString('#a855f7')
      default: return Cesium.Color.BLUE
    }
  }

  return (
    <div className={`relative w-full h-full min-h-[600px] ${isFullscreen ? 'fixed inset-0 z-50 bg-black' : ''}`}>
      {/* Cesium Container - FIX 1: Ensure container has size BEFORE viewer init */}
      <div
        ref={cesiumContainer}
        className="w-full h-full bg-gray-900"
        style={{
          width: '100%',
          height: '100%',
          minHeight: '400px'
        }}
      />

      {/* Control Panel */}
      <div className={`absolute ${isFullscreen ? 'top-4 right-4' : 'top-4 right-4'} space-y-2`}> 
        <button
          onClick={handleFitToView}
          className="bg-gray-900 bg-opacity-80 text-white p-2 rounded hover:bg-opacity-100 transition-all"
          title="Fit to view"
        >
          <Maximize2 className="h-5 w-5" />
        </button>
        
        <button
          onClick={handleResetCamera}
          className="bg-gray-900 bg-opacity-80 text-white p-2 rounded hover:bg-opacity-100 transition-all"
          title="Reset camera"
        >
          <Navigation className="h-5 w-5" />
        </button>
        
        <button
          onClick={toggleBuildings}
          className="bg-gray-900 bg-opacity-80 text-white p-2 rounded hover:bg-opacity-100 transition-all"
          title={showBuildings ? 'Hide buildings' : 'Show buildings'}
        >
          {showBuildings ? <Eye className="h-5 w-5" /> : <EyeOff className="h-5 w-5" />}
        </button>

        {enableFullscreen && (
          <button
            onClick={handleFullscreenToggle}
            className="bg-gray-900 bg-opacity-80 text-white p-2 rounded hover:bg-opacity-100 transition-all"
            title={isFullscreen ? 'Exit fullscreen' : 'Fullscreen map'}
          >
            {isFullscreen ? <Shrink className="h-5 w-5" /> : <Expand className="h-5 w-5" />}
          </button>
        )}
      </div>

      {/* Legend */}
      <div className="absolute bottom-4 left-4 bg-gray-900 bg-opacity-80 text-white p-3 rounded space-y-2 text-sm">
        <div className="font-semibold mb-2">Legend</div>
        <div className="flex items-center gap-2">
          <div className="w-3 h-3 rounded-full bg-green-500"></div>
          <span>Active</span>
        </div>
        <div className="flex items-center gap-2">
          <div className="w-3 h-3 rounded-full bg-yellow-500"></div>
          <span>Idle</span>
        </div>
        <div className="flex items-center gap-2">
          <div className="w-3 h-3 rounded-full bg-orange-500"></div>
          <span>Maintenance</span>
        </div>
        <div className="flex items-center gap-2">
          <div className="w-3 h-3 rounded-full bg-red-500"></div>
          <span>Emergency</span>
        </div>
        <div className="flex items-center gap-2">
          <div className="w-3 h-3 rounded-full bg-gray-500"></div>
          <span>Offline</span>
        </div>
      </div>

      {/* Camera Mode Indicator */}
      {cameraMode === 'follow' && followDrone && (
        <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-blue-600 text-white px-4 py-2 rounded-full shadow-lg">
          <div className="flex items-center gap-2">
            <Navigation className="h-4 w-4 animate-pulse" />
            <span className="font-semibold">
              Following {drones.find(d => d.id === followDrone)?.serial_number}
            </span>
          </div>
        </div>
      )}

      {/* Collision Alert Banner */}
      {collisions.length > 0 && (
        <div className="absolute top-20 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-6 py-3 rounded-lg shadow-2xl animate-pulse z-50">
          <div className="flex items-center gap-3">
            <AlertTriangle className="h-6 w-6" />
            <div>
              <div className="font-bold text-lg">üö® CODE RED - COLLISION DETECTED</div>
              <div className="text-sm">
                {collisions[collisions.length - 1].droneSerial} - {collisions[collisions.length - 1].type} collision at {collisions[collisions.length - 1].timestamp.toLocaleTimeString()}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Stats Overlay */}
      <div className="absolute top-4 left-4 bg-gray-900 bg-opacity-80 text-white p-3 rounded space-y-1 text-sm">
        <div className="font-semibold mb-2">Map Stats</div>
        <div>Total Drones: <span className="text-green-400">{drones.length}</span></div>
        <div>Active Drones: <span className="text-green-300">{drones.filter(d => ['delivering', 'in_transit', 'assigned', 'active', 'returning'].includes(d.status || '')).length}</span></div>
        <div>Crashed Drones: <span className="text-red-500">{crashedDrones.size}</span></div>
        <div>Active Routes: <span className="text-cyan-400">{routes.length}</span></div>
        <div>Zones: <span className="text-yellow-400">{zones.length}</span></div>
        <div>Buildings: <span className={showBuildings ? 'text-green-400' : 'text-gray-400'}>{showBuildings ? 'Shown' : 'Hidden'}</span></div>
        {collisions.length > 0 && (
          <div className="mt-2 pt-2 border-t border-red-500">
            <div className="text-red-400 font-semibold">‚ö†Ô∏è Collisions: {collisions.length}</div>
          </div>
        )}
      </div>
    </div>
  )
}